import{_ as a,o as e,c as r,a as h}from"./app-rhaCkHXY.js";const i="/vuepress-blog/assets/1702866271458-wqPEB2XC.png",t="/vuepress-blog/assets/1702868683150-F7pF8YX2.png",s={},d=h('<h1 id="浏览器知识点" tabindex="-1"><a class="header-anchor" href="#浏览器知识点" aria-hidden="true">#</a> 浏览器知识点</h1><h2 id="_1、什么是进程" tabindex="-1"><a class="header-anchor" href="#_1、什么是进程" aria-hidden="true">#</a> 1、什么是进程？</h2><p>简单来说，进程就是程序运行的一个内存空间，每个应用至少有一个进程，进程之间相互独立隔离，即使要通信，也需要双方同意。</p><h2 id="_2、什么是线程" tabindex="-1"><a class="header-anchor" href="#_2、什么是线程" aria-hidden="true">#</a> 2、什么是线程？</h2><p>有了内存空间或者说线程了之后，就可以运行程序的代码了，而运行代码的叫做线程。所以一个进程至少有一个线程，在进程开启后会自动创建一个线程来运行代码，该线程称为主线程。 如果说程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p><h2 id="_3、那么浏览器会有哪些进程" tabindex="-1"><a class="header-anchor" href="#_3、那么浏览器会有哪些进程" aria-hidden="true">#</a> 3、那么浏览器会有哪些进程？</h2><p>浏览器是一个多进程多线程的应用程序。它的内部工作环境是极其复杂，为了避免互相影响以及减少连环崩溃的几率，当启动浏览器时，它会自动启动多个线程，如:浏览器进程、网络进程、渲染进程等。 当我们在chrome浏览器的更多工具找到任务管理器，打开后发现，浏览器有很多个进程，占用了很多内存空间，其中浏览器进程和GPU进程占了很多内存。但是最占内存的还是渲染进程，默认情况下，每一个标签页就是一个渲染进程，如果标签页每打开多一个，进程就多一个，占用的内存空间多一个。 <img src="'+i+'" alt="Alt text"></p><h3 id="_3-1-浏览器进程是干嘛用的" tabindex="-1"><a class="header-anchor" href="#_3-1-浏览器进程是干嘛用的" aria-hidden="true">#</a> 3.1 浏览器进程是干嘛用的？</h3><p>它主要负责浏览器界面的展示，比如说窗口标签页、按钮、导航栏等这些界面样式的展示，也包括用户的交互，如点击、鼠标滚动等交互事件，浏览器需要对这些用户事件进行监听。 此外浏览器进程还负责对子进程的管理等，它的内部还会启动多个线程来处理不同的任务。</p><h3 id="_3-2-渲染进程是做什么用的" tabindex="-1"><a class="header-anchor" href="#_3-2-渲染进程是做什么用的" aria-hidden="true">#</a> 3.2 渲染进程是做什么用的？</h3><p>渲染进程启动后，会开启一个渲染主线程，它负责执行HTML、CSS还有JS代码，所有前端代码都是在这个线程上执行的。</p><h2 id="_4、渲染主线程是如何工作的" tabindex="-1"><a class="header-anchor" href="#_4、渲染主线程是如何工作的" aria-hidden="true">#</a> 4、渲染主线程是如何工作的?</h2><p>渲染主线程是浏览器中最繁忙的线程，平时我们只是写个代码就好了，但是它却要完成一系列的任务，包括但不限于：</p><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画 60 次，这里可以理解为我们平时说的帧率</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>等等......</li></ul><p>那么问题来了，它都这么忙了，为什么不调用多个线程去处理不同的任务呢？</p><h2 id="_5、为了处理这么多的任务-浏览器应该如何调度任务呢" tabindex="-1"><a class="header-anchor" href="#_5、为了处理这么多的任务-浏览器应该如何调度任务呢" aria-hidden="true">#</a> 5、为了处理这么多的任务，浏览器应该如何调度任务呢？</h2><p>浏览器做了这些事情：</p><p>1、在最开始的时候，渲染主线程会开启一个无限循环，如while(true){...},这里可以看一下浏览器的源码，用c++写的，如图：<img src="'+t+'" alt="Alt text">，它是一个for的无限循环，我们用js也可以实现一样的效果，通常我们for循环是这样的for(var i=0;i&lt;array.length;i++){}, 如果写成for( ; ; ),那就是条件永远为true，无限循环。 2、每次循环，浏览器做了什么？它会检查消息队列中是否有任务，有任务的话，就取出第一个任务执行，执行完就开始下一个循环，毕竟这是一个无限循环，如果没有任务的话，则进入休眠状态。 3、其他所有线程（包括其他进程的线程）可以随时像消息队列添加任务，新任务会加到任务队列的最后面。如果添加新任务的时候，主线程是休眠状态，就会将其唤醒并继续循环从消息队列中拿任务去执行。 4、浏览器给不同的任务进行排队，以及设置优先级，比如说设置了vip优先通道，剩下的是其它队列通道。就很像在窗口办理业务，需要我们排队，渲染主线程就是当前在处理业务的窗口，而消息队列（message queue）/事件队列则是后面在排队的队伍。队列的任务可能来自于渲染主线程中处理任务产生的新的任务，也可能来自于其他线程，如用户产生交互是由浏览器进程进行监听的，这个任务就是来自于浏览器进程的线程。 如果说主线程还在执行任务的时候，用户点击了按钮，这个时候不会立即执行点击事件的处理函数，而是先让这个处理任务去排队，主线程执行完了之后也不一定会执行这个处理任务，而且先把消息队列中的优先级最高的那个任务先拿到主线程去处理，直到排到这个任务。</p><h2 id="_6、什么是异步任务" tabindex="-1"><a class="header-anchor" href="#_6、什么是异步任务" aria-hidden="true">#</a> 6、什么是异步任务？</h2><p>在代码的执行过程中，会遇到一些无法立即处理的任务，如： 计时器：setTimeout、setInterval。 网络通信完成后执行的任务，如XHR、Fetch。 用户操作后执行的任务。 如果说要等到这些任务处理的时机达到，那主线程就会处于长期阻塞的状态，要知道，渲染主线程还要承担绘制的任务，也就是每秒在页面绘制60次，如果主线程阻塞了，那浏览器就会处于一个卡死的状态。 如果说我们改变了dom元素的样式属性或者文本内容，浏览器就会产生一个新的绘制任务，假如在处理某个任务的时候，先执行改变dom元素的文本，再执行一个需要执行特定时间的任务，如3s，那么会发生什么？答案是，页面上过了3s后，才改变了这个元素的文本，这就是因为刚刚这个绘制任务排队了。 如果说使用了setTimeout的话，渲染主线程是怎么做的呢？首先这个计时会由另外一个计时线程去处理，计时完成后，再将setTimeout里的回调函数任务添加到消息队列的最后一位。 正因为存在这种异步任务的模式，才使得主线程不至于被阻塞。</p><h3 id="_6-1-面试题-如何理解-js-的异步" tabindex="-1"><a class="header-anchor" href="#_6-1-面试题-如何理解-js-的异步" aria-hidden="true">#</a> 6.1 面试题：如何理解 JS 的异步？</h3><blockquote><p>参考答案： JS是一门单线程的语言，（因为浏览器就一个线程在执行js）这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p><p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，（将回调函数包装成任务，这个需要研究过浏览器源码才知道，所有的任务都是一个结构体，可以理解为一个对象）加入到消息队列的末尾排队，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p></blockquote><h2 id="_7、任务有优先级吗" tabindex="-1"><a class="header-anchor" href="#_7、任务有优先级吗" aria-hidden="true">#</a> 7、任务有优先级吗？</h2><p>准确来说，任务是没有优先级的，在消息队列中先进先出，但是。消息队列有优先级。 根据 W3C 的最新解释:</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行 https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</li></ul><blockquote><p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p></blockquote><p>在目前 chrome 的实现中，至少包含了下面的队列：</p><ul><li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li><li>微队列：用户存放需要最快执行的任务，优先级「最高」</li></ul><blockquote><p>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p></blockquote><h2 id="_8、面试题-阐述一下-js-的事件循环" tabindex="-1"><a class="header-anchor" href="#_8、面试题-阐述一下-js-的事件循环" aria-hidden="true">#</a> 8、面试题：阐述一下 JS 的事件循环</h2><blockquote><p>参考答案：</p><p>事件循环又叫做消息循环，W3C官方描述叫事件循环，浏览器的内部实现叫消息循环，是浏览器渲染主线程的工作方式。</p><p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p><p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务，比如说延时队列和交互队列，其中交互队列的任务优先级更高，浏览器会更优先在交互队列中取任务去渲染主线程执行。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p></blockquote><h2 id="_9、js中的计时器能做到精准计时吗" tabindex="-1"><a class="header-anchor" href="#_9、js中的计时器能做到精准计时吗" aria-hidden="true">#</a> 9、JS中的计时器能做到精准计时吗？</h2><p>答案是不能，因为： 1、计算机硬件没有原子钟，无法做到精确计时。 2、js的计时器是调用操作系统的函数，而操作系统的计时函数本身就有少量的偏差。浏览器中也针对不同系统windows和mac调用了不同函数。 3、根据W3C官方的解释，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差。 4、受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，如果主线程任务没有执行完，就轮不到计时器的回调函数任务执行，因此又带来了偏差。</p><p>事件循环机制的总结：单线程是异步产生的原因，事件循环是异步的实现方式。</p><h2 id="_10、什么叫浏览器的渲染" tabindex="-1"><a class="header-anchor" href="#_10、什么叫浏览器的渲染" aria-hidden="true">#</a> 10、什么叫浏览器的渲染?</h2><p>就是将一个html的字符串变成屏幕上的像素信息，就叫浏览器的渲染。当我们输入一个url地址的时候，实际上拿到的是一个html，这一点我们可以在网页上点击右键查看网页的源代码可以看到。</p><h2 id="_11、浏览器的渲染流程是怎样的" tabindex="-1"><a class="header-anchor" href="#_11、浏览器的渲染流程是怎样的" aria-hidden="true">#</a> 11、浏览器的渲染流程是怎样的？</h2><p>网络进程中的线程通信拿到了html，生成一个渲染任务，给消息队列排队，再到渲染主线程处理渲染任务。渲染任务包括以下流程：1、HTML解析 2、样式计算 3、布局 4、分层 5、绘制 6、分块 7、光栅化 8、画</p><h3 id="_11-1-html解析的第一步" tabindex="-1"><a class="header-anchor" href="#_11-1-html解析的第一步" aria-hidden="true">#</a> 11.1 HTML解析的第一步？</h3><p>解析的第一步就是产生dom树和cssom树。 dom树是一个树形结构的对象，严格来说这个dom树是c++的对象，但是我们在js操作的是js的对象。 字符串很难进行操作，对象结构更易于操作。 cssom树，指的是网页中的样式表，包括style标签，link外部样式表，内联样式表，浏览器默认样式表（user agent stylesheet）,每个样式里有很多规则，规则里有选择器，有样式，每个样式有多个键值对。 通过document.styleSheets可以访问到StyleSheetList,即cssom树的根部对象，考虑到它应该是一个c++的对象，外层包了一层js的对象的可能，我认为，用js的类型来看，它应该是一个类数组，即是一个对象，但是存在length属性。 将css字符串解析成cssom树，也是一个对象结构，这样是为了后续js对css的操作。</p><h3 id="_11-2-解析html的过程中遇到css-浏览器是怎么做的" tabindex="-1"><a class="header-anchor" href="#_11-2-解析html的过程中遇到css-浏览器是怎么做的" aria-hidden="true">#</a> 11.2 解析html的过程中遇到css，浏览器是怎么做的？</h3><p>为了提高解析效率，浏览器会启动一个预解析器率先下载和解析css，让另外一个线程处理css。 解析html中的css因为有预解析器下载和解析css生成cssom树，并不会阻塞html的解析。 如果是遇到js代码，比如解析到script标签，会停止一切行为，等待下载完成、执行js代码后才能继续解析html，为什么呢？因为js代码可能会改动到dom，而dom不是解析完才生成的，是一边解析一边生成的。</p><h3 id="_11-3-html解析的第二步" tabindex="-1"><a class="header-anchor" href="#_11-3-html解析的第二步" aria-hidden="true">#</a> 11.3 HTML解析的第二步？</h3><p>第一步完成后，我们得到了一个dom树和cssom树，通过dom树和cssom树计算最终样式，在浏览器的调试工具中可以看到，在computed里，showall可以看到每一个样式都有值。假如我们写color:red,最终会变成color:rgb(255,0,0)。最终得到的还是一个dom树，不过现在每个dom节点都有样式了，但是还是看不到界面，因为还没有生成像素点。</p><h3 id="_11-4-html解析的第三步" tabindex="-1"><a class="header-anchor" href="#_11-4-html解析的第三步" aria-hidden="true">#</a> 11.4 HTML解析的第三步？</h3><p>这一步叫布局，就是根据dom节点的样式来算出每个节点的尺寸和位置。最终计算布局出来的布局树和dom树不一定是一一对应的，比如说某个dom节点上样式存在属性display:none，那么布局树上就没有该节点。比如head、link、script等元素就是默认display:none的，这些dom节点没有几何信息，不生成到布局树。再比如在dom节点上使用了伪元素选择器如::before，在布局树上是一个节点，而dom树没有这个节点。 内容必须在行盒中，行盒和块盒不能相邻,(目前没有行级元素块级元素的叫法)，由于这两个规则，在布局树中会生成匿名行盒和匿名块盒。</p><h3 id="_11-5-html解析的第四步" tabindex="-1"><a class="header-anchor" href="#_11-5-html解析的第四步" aria-hidden="true">#</a> 11.5 HTML解析的第四步？</h3><p>第四步是分层，分层的好处是，如果将来某一层改变后，近会对改成进行后续处理，从而提高效率。在浏览器的调试工具的Layers栏可以看到当前页面的分层状态。比如滚动条就单独占了一层，鼠标每滚动，滚动条就要重画一次。如果我们希望某个div单独分层，防止重绘过多，可以加一个属性如will-change:transform就会分一层。但是不能滥用，分层过多会占用更多内存空间。</p><h3 id="_11-6-html解析的第五步" tabindex="-1"><a class="header-anchor" href="#_11-6-html解析的第五步" aria-hidden="true">#</a> 11.6 HTML解析的第五步？</h3><p>第五步是绘制，还不是生成像素，这里指的是生成绘制指令，如:将笔移动到（10,30）的位置，画一个200*300的矩形，用红色填充改矩形，这就是绘制指令。canvas的画用的就是浏览器内核的绘制功能，属于浏览器开放出来的功能。</p><h3 id="_11-7-html解析的第六步" tabindex="-1"><a class="header-anchor" href="#_11-7-html解析的第六步" aria-hidden="true">#</a> 11.7 HTML解析的第六步？</h3><p>在绘制这一步过后，渲染主线程的工作就到此为止了，剩余的步骤交给其他线程完成。而第六步为分块，分块会将每一层分为多个小的区域。分块的工作是交给多个线程同时进行，具体是渲染进程中的合成线程从线程池中拿取多个合成块线程来完成分块。</p><h3 id="_11-8-html解析的第七步" tabindex="-1"><a class="header-anchor" href="#_11-8-html解析的第七步" aria-hidden="true">#</a> 11.8 HTML解析的第七步？</h3><p>第七步是光栅化，光栅化是将每个块变成位图，优先处理靠近视口的块。啥叫位图，位图就是每个像素点的信息，比如有一个块有多少个像素点，每个像素点的颜色等信息。光栅化是在GPU进程里做的，会用到GPU加速。</p><h3 id="_11-9-html解析的第八步" tabindex="-1"><a class="header-anchor" href="#_11-9-html解析的第八步" aria-hidden="true">#</a> 11.9 HTML解析的第八步？</h3><p>第八步最后一步就是画，draw。合成线程在分块、光栅化之后，拿到每个层、每个块的位图后，生成一个个的指引信息，指引会标识出每个位图应该画到屏幕的哪个位置，以及考虑旋转、缩放等变形（transform）。变形发生在合成线程，和渲染主线程无关，这就是transform效率高的本质原因。合成线程把这些指引信息提交给GPU进程，由GPU进程产生系统调用，提交给GPU硬件完成最终的屏幕成像。</p><p>当我们移动滚动条的时候，就影响到页面和视口位置，会从重新执行这一步的。</p><h2 id="_12、什么是reflow" tabindex="-1"><a class="header-anchor" href="#_12、什么是reflow" aria-hidden="true">#</a> 12、什么是reflow？</h2><p>当我们改变了页面几何信息的时候，如改变宽度，增加dom元素等，会启动一系列的重新计算，这就是reflow，重新布局重新排版的意思，也叫回流。本质上就是重新计算layout树，相当于从第三步重新开始到第八步。不过为了提高效率，避免多次连续的改动多次计算，浏览器会合并这些改动操作，当js代码全部完成后再统一计算，所以，改动属性造成的reflow是异步完成的。也因为如此，当js获取布局属性时，可能造成无法获取到最新的布局信息。浏览器在反复权衡下，最终决定获取属性立即reflow。也可以说改写是异步reflow，读取是同步reflow。</p><h2 id="_13、什么是repaint" tabindex="-1"><a class="header-anchor" href="#_13、什么是repaint" aria-hidden="true">#</a> 13、什么是repaint？</h2><p>repaint也叫重绘，本质就是重新根据分层信息计算绘制指令，对应HTML解析的第五步。改动了可见样式，如背景颜色，就需要重新计算，会引起repaint，由于元素的布局信息也属于可见样式，reflow也会引起repaint。</p><h2 id="为什么-transform-的效率高" tabindex="-1"><a class="header-anchor" href="#为什么-transform-的效率高" aria-hidden="true">#</a> 为什么 transform 的效率高？</h2><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>',64),l=[d];function o(n,c){return e(),r("div",null,l)}const m=a(s,[["render",o],["__file","浏览器学习笔记.html.vue"]]);export{m as default};
