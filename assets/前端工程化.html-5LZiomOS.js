import{_ as a,o as e,c as r,a as h}from"./app-rhaCkHXY.js";const s={},i=h('<h1 id="前端工程化概念梳理" tabindex="-1"><a class="header-anchor" href="#前端工程化概念梳理" aria-hidden="true">#</a> 前端工程化概念梳理</h1><h2 id="前端工程化有什么意义" tabindex="-1"><a class="header-anchor" href="#前端工程化有什么意义" aria-hidden="true">#</a> 前端工程化有什么意义？</h2><p>前端工程化就是对前端项目的管理，降低管理成本，提高开发效率。</p><h2 id="如何理解模块化" tabindex="-1"><a class="header-anchor" href="#如何理解模块化" aria-hidden="true">#</a> 如何理解模块化？</h2><p>分解和聚合。简单来讲就是不同的功能写在不同的js文件。在过去没有模块化的时候，也就是在html引入js文件的时候，文件之间是存在问题的，如全局污染，依赖混乱。 由于存在这些问题，一些模块化的标准就被提出来，如CommonJs,AMD,CMD,UMD,ESM...它们各自去提出一些方案，为了分解的时候，隐藏内部实现，不污染全局，聚合的时候，能够明确的表达依赖关系。其中ESM为2015后出现的官方模块化的标准，是编译时，意味着运行代码前就要确认好依赖关系，要放在代码的最顶层。CJS为社区提出的标准，在以前很多node环境用的，是运行时，只有运行到代码的时候才确定依赖关系。 浏览器只支持 ESM，node CJS，ESM都支持，webPack两者都支持，rollup、esbuilder默认只支持ESM，可以通过插件支持CJS，不管什么构建工具，都推荐使用ESM模块化标准。</p><h2 id="如何理解包管理" tabindex="-1"><a class="header-anchor" href="#如何理解包管理" aria-hidden="true">#</a> 如何理解包管理？</h2><p>包，也就是package，一系列模块的集合。现在主要还是用npm来管理包，主要有包的属性，下载地址，cli（命令行的操作界面），别的包管理工具如pnpm，yarn，cnpm，bower等，pnpm，yarn更好点。</p><h2 id="说说语言的兼容性问题" tabindex="-1"><a class="header-anchor" href="#说说语言的兼容性问题" aria-hidden="true">#</a> 说说语言的兼容性问题？</h2><h3 id="_1、api兼容" tabindex="-1"><a class="header-anchor" href="#_1、api兼容" aria-hidden="true">#</a> 1、API兼容</h3><p>比如说在低版本的环境中不支持某个高版本支持的api，应该怎么解决，polyfill，翻译为填充物、垫片，意思是如果当前环境没有这个api，重写一遍这个api，给它填充进去。目前来完成这个polyfill最主流的工具是core-js,不过polyfill并不是100%能解决问题，涉及到浏览器原生的能力的，如微队列，不能使用promise，observer的，新老版本浏览器还是会有一些细微的区别。</p><h3 id="_2、语法兼容" tabindex="-1"><a class="header-anchor" href="#_2、语法兼容" aria-hidden="true">#</a> 2、语法兼容</h3><p>同理，低版本的环境不支持的语法，就需要进行语法转换，但是不同的语法用的是不同的转换工具，比如转换async await，可以用regenerator这个工具。</p><h3 id="_3、语法增强" tabindex="-1"><a class="header-anchor" href="#_3、语法增强" aria-hidden="true">#</a> 3、语法增强</h3><p>和语法兼容一样，只需要有相应的转换工具，就能把jsx、typescript这样的语法转换成js。</p><h2 id="代码集成转换工具" tabindex="-1"><a class="header-anchor" href="#代码集成转换工具" aria-hidden="true">#</a> 代码集成转换工具</h2><p>由于API兼容 、语法兼容、语法增强等问题的出现，我们需要一些工具来解决这些问题，但是涉及到的工具太多，对我们的开发效率影响很大，不好整合，我们正需要一个工具，帮我们把这些前面这些工具来自动处理，不需要我们开发的时候手动处理问题。 这样的工具就叫代码集成转换工具，而用的最多的就是babel。</p><h3 id="babel做的事是啥呢" tabindex="-1"><a class="header-anchor" href="#babel做的事是啥呢" aria-hidden="true">#</a> babel做的事是啥呢？</h3><p>我们的原始代码叫个bable进行转换，转换成啥呢，转换成一个AST，叫抽象语法树。它是一个树形结构，有点类似一个dom树，有很多嵌套的属性，便于分析。转成抽象语法树之后再转成代码，这就是babel做的事情。 看上去bable做的事很简单，但是babel留了扩展的点，也就是从AST转成代码的这一步，这些操作我们成为插件。 比如要处理可选链操作符语法的插件，使用命令 npm i -D @babel/plugin-transform-optional-chaining安装插件,在根目录下的babel.config.js中配置插件。 不过babel能够支持预设，安装@babel/preset-env这个插件，安装它就相当于安装一堆插件。</p><h2 id="css作为一门语言存在哪些问题" tabindex="-1"><a class="header-anchor" href="#css作为一门语言存在哪些问题" aria-hidden="true">#</a> css作为一门语言存在哪些问题？</h2><p>1、语法缺失（循环、判断、拼接） 2、功能缺失（颜色函数、数学函数、自定义函数）</p><h3 id="如何解决css存在的这些问题" tabindex="-1"><a class="header-anchor" href="#如何解决css存在的这些问题" aria-hidden="true">#</a> 如何解决css存在的这些问题？</h3><p>开发一门新语言，通过css预编译器转成css语言，如：sass，less，stylus。不过通过这些css预编译器生成的语言还有一些问题要解决：1、厂商前缀（兼容性）；2、代码压缩；3、代码剪枝(没有用到的代码不要生成到css里)，4、类名冲突等。处理这些事情的被称为后处理器，比如PostCSS，它也是将css代码转换成抽象语法树，然后这期间通过一系列插件处理，最终生成css。不过PostCSS也可以支持sass。可以把PossCSS理解为是css语言的babel，其中像tailwind是PossCSS的一个插件。</p><h2 id="工程层面的转换" tabindex="-1"><a class="header-anchor" href="#工程层面的转换" aria-hidden="true">#</a> 工程层面的转换？</h2><p>指的就是传统方面的工程结构，也就是我们之前使用构建工具打包输出的文件。有哪些构建工具?webpack,rollup,esbuild,turbopack,snowpack,grunt,gulp,Rspack。</p><h2 id="webpack的一些问题" tabindex="-1"><a class="header-anchor" href="#webpack的一些问题" aria-hidden="true">#</a> webpack的一些问题？</h2><h3 id="_1-哪种工程更适合开发和维护" tabindex="-1"><a class="header-anchor" href="#_1-哪种工程更适合开发和维护" aria-hidden="true">#</a> 1.哪种工程更适合开发和维护？</h3><p>一切皆为模块</p><h3 id="_2、哪种工程更适合运行时" tabindex="-1"><a class="header-anchor" href="#_2、哪种工程更适合运行时" aria-hidden="true">#</a> 2、哪种工程更适合运行时？</h3><p>传统工程</p><h3 id="_3、如何转换-打包" tabindex="-1"><a class="header-anchor" href="#_3、如何转换-打包" aria-hidden="true">#</a> 3、如何转换（打包）？</h3><p>以一个文件为入口点出发，查找有哪些依赖关系，然后进行一个深度的遍历，寻找所有依赖关系，最后合并在一起。比如在webpack的配置文件中，可以配置入口文件，通常配置为src/main.js。那么它是怎么分析有哪些依赖关系的呢？它将整个文件的代码当做一个字符串，并分解称为一个AST，通过这个抽象语法树找到导入语句。如：import语句和require语句，其中实现会有很多细节，比如说依赖的路径是一个文件夹，那么会找文件夹中的index.js，比如我们引入的是npm包，文件路径不以./这样的开头，如import &quot;jquery&quot;，那么它会查到当前目录是否有node_modules这个文件夹，没有的话到上一级目录找，直到找到node_modules，然后呢，找到对应名称的文件夹，如jquery，然后在这个文件夹的package.json文件中，找到main这个属性值的路径，按这个路径去找，找到后一起参与打包。</p><h3 id="_4、如何一边开发一边运行" tabindex="-1"><a class="header-anchor" href="#_4、如何一边开发一边运行" aria-hidden="true">#</a> 4、如何一边开发一边运行？</h3><p>使用开发服务器，它是webpack内置的一个库，叫做webpack-dev-server，而它里面又依赖了express，在内存中形成打包结果，通过开发服务器在打包结果取出内容，响应给浏览器。如果源码变化了，会重新打包，刷新页面。这是因为webpack能监听到文件变化，从而触发重新打包。如何触发浏览器自动刷新的又涉及到了websocket，需要深入去了解。</p><h3 id="_5、打包文件的文件指纹是什么" tabindex="-1"><a class="header-anchor" href="#_5、打包文件的文件指纹是什么" aria-hidden="true">#</a> 5、打包文件的文件指纹是什么？</h3><p>比如说打包后的js文件名为app-xxxxx.js，如果我们改变源码后打包，每次的文件名都不一样，这是为了浏览器的缓存，如果说名称都一样，那么浏览器不知道文件是否改变。</p><h3 id="_6、css-modules" tabindex="-1"><a class="header-anchor" href="#_6、css-modules" aria-hidden="true">#</a> 6、css modules</h3><p>为了避免类名冲突，合并后类名都变了。比如说导入一个less，得到一个对象，通过这个对象的container属性，就拿到了类名对应关系。</p><h3 id="_7、源码地图-source-map" tabindex="-1"><a class="header-anchor" href="#_7、源码地图-source-map" aria-hidden="true">#</a> 7、源码地图（source-map）</h3><p>如果开启源码地图，可以让我们在调试工具中找到源码调试，关闭后就找不到源码而是打包后的代码。</p><h3 id="_8、webpack总结" tabindex="-1"><a class="header-anchor" href="#_8、webpack总结" aria-hidden="true">#</a> 8、webpack总结</h3><p>webpack通过它的两个扩展点，一个是loader，一个是plugin，加载器和插件，可以将我们之前的代码转换的各种工具全部融入进来。</p><h2 id="脚手架" tabindex="-1"><a class="header-anchor" href="#脚手架" aria-hidden="true">#</a> 脚手架</h2><p>1、提供界面和交互 2、提供一套工程模板</p><h2 id="知识体系梳理" tabindex="-1"><a class="header-anchor" href="#知识体系梳理" aria-hidden="true">#</a> 知识体系梳理</h2><ul><li>语言</li><li>协议</li><li>环境</li><li>框架/库</li><li>工程化</li></ul>',45),d=[i];function n(c,p){return e(),r("div",null,d)}const t=a(s,[["render",n],["__file","前端工程化.html.vue"]]);export{t as default};
